# 浏览器缓存

## 强缓存
缓存在客户端的资源，不需要发http请求，返回状态吗为200。http1.0 通过Expires，而http1.1通过Cache-Control

### http1.0 / Expries
该字段存于相应头，表示资源具体的过期时间，告诉客户端在这个时间之前，都可以从缓存中获取资源，而如果过期了就需要向服务端发请求。
`注意`：服务器时间于客户端时间并不一定一致，故缓存时间也存在一定误差

### http1.1 / Cache-Control
该字段也存于相应头，不表示具体某个时间，而是采用时长来控制缓存，如
```js
Cache-Control:max-age=3600
```
表示这个请求相应后的3600秒，都可以直接使用缓存。
除了max-age，表示最长缓存时长，还有其他常用的字段
 - private 表示只使用浏览器缓存，不采用代理服务器缓存
 - no-cache 跳过强缓存，直接进入协商缓存
 - no-store 不进行任何形式的缓存
 - s-maxage 针对代理服务器的缓存时长

### Expries 与 Cache-Control 共存
优先考虑Cache-Control

## 协商缓存
强缓存过期后，需要发送http请求，在请求头携带缓存tag，服务端根据tag来决定使用缓存。有两种方式 Last-Modifed 和 Etag

### Last-modified
资源最后修改时间，使用过程如下：
 - 当第一次请求响应后，相应头会加入该字段。
 - 再次发送请求，会在请求头加入 If-Modified-Since字段，即上一次请求返回的资源最后修改时间。
 - 服务器拿到If-Modified-Since字段，与资源最后修改时间做对比
 - 1⃣️如果时间小于最后修改时间，则说明服务端的资源已被修改，需要更新资源到客户端；2⃣️否则返回304，告诉浏览器使用缓存

### Etag
根据资源内容，给文件生成唯一标识，当内容发生改变，该标识也会改变。使用过程如下
 - 第一次请求相应后，服务端通过响应头将该值给客户端
 - 再次发生请求，请求头加入 If-None-Match字段，将上次Etag标识加入发给服务端
 - 服务 If-None-Match后，与服务器资源Etag进行对比
 - 1⃣️如果两者不一致，则说明资源内容被修改，需要更新资源到客户端；2⃣️否者返回304，告诉浏览器使用缓存

### 对比
 - 精准度，Etag要优于Last-modified；Etag对资源感知更敏感，而Last-modified有一定的局限性：1⃣️修改了资源，但内容并未改变；2⃣️最小感知单位为秒，在一秒之间频繁修改文件，并无法感知是否发生变化
 - 性能上，Last-Modified优于ETag。Etag根据资源内容生成哈希值，而Last-modified只是记录一个修改时间

### Last-modified与Etag共存
服务器优先考虑Etag