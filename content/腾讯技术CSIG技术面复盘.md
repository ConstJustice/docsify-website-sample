### 腾讯技术面复盘

重点知识： HTTP协议、代理、缓存、转发

1. ES6新特性有哪些？

2. 服务器code 301、 302编码区别
   
   100-199： 极少看见，浏览器内部引用的编码
   
   200-299：操作成功编码
   

200-299：操作成功编码

   300-399：重定向编码，本质上，它们告诉Web浏览器必须执行其它一些操作以完成请求。基于这个命令的特点，它可以自动地执行，或者要求额外的用户输入

   400-499：客户端错误码，如果一个客户端尝试访问一个未授权访问的资源，服务器就会返回一个状态码401。类似地，如果客户端尝试访问一个禁止的资源，在这种情况下客户端的认证状态是一样的，那么服务器可能会返回一个状态码403，表示禁止对该资源进行访问

   500-599：服务器错误。比如，如果Web服务器超时，它就会产生一个504错误，虽然，一个500级的错误往往表示的不是服务器的问题，而是在服务器上运行的Web应用的问题

   http 协议的 301 和 302 状态码都代表重定向。浏览器请求某url收到这两个状态码时，都会显示和跳转到 Response Headers 中的Location。即在浏览器地址输入 url A，却自动跳转到url B。不同之处在于： 
   301 redirect: 301 代表永久性转移(Permanently Moved)。
   302 redirect: 302 代表暂时性转移(Temporarily Moved )
   **302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。**
   **而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址**

3. 解决跨域有哪些常见手段
   JSONP/ CROS请求（简单请求和复杂请求，本质是在请求头部添加origin字段）/正向代理以及反向代理
   所谓正向代理，是客户为了从源服务器中取得内容，由客户端向代理服务器发出请求，并指定目标访问服务器，然后，代理服务器向源服务器转交需求，并将获得的内容返回给客户端。需要注意的是，在正向代理过程中隐藏了真实请求的客户端，即服务端不知道正式请求客户是谁。（科学上网）

   所谓反向代理，是客户端向反向代理发出请求，反向代理服务器收到需求后判断请求走向何处，然后再将结果反馈给客户端。同样需要注意的是，在反向代理过程中，隐藏了内部服务器的信息，用户不需要知道是具体哪一台服务器提供的服务，只要知道反向代理服务器是谁就好了，我们甚至可以把反向代理服务器当做真正服务器看待。这种形式的代理通常被用作实现负载均衡，比如Nginx就是一种出色的反向代理服务器。

   反向代理解决跨域问题：我们前端在使用 vue-cli 这种脚手架工具进行开发时，经常会遇到跨域的问题，因为项目自身启动本地服务是需要占用一个端口（如 http://localhost:8080）的，所以必然会产生跨域的问题（因为本地服务端口和服务端接口地址不是同源）。在使用webpack做构建工具的项目中，经常会使用proxyTable代理实现跨域（具体实现自行百度）。之所以出现跨域是因为浏览器有同源策略的限制，但服务器是没有的同源策略的限制的。当我们本地服务（假设域名：http://localhost:8080）要请求目标服务器（假设域名：http://target.com）的资源的时候，我们不直接请求 target.com，而是请求本地服务自身 http://localhost:8080（这时是同源请求，不存在跨域），本地代理服务再将接口转发给 target.com（注意这时候是两个服务器直接的通信了，而不是客户端和服务器的通信，所以更不存在跨域），本地服务获取到目标服务器的响应数据之后通过再代理伪装成本地服务请求的返回值返回给客户端。

4. vue diff算法做了哪些的优化
   过程：Template -> compile => Render渲染函数 => VNode => VDOM => Patch(diff算法) => view
   **传统diff算法通过循环递归对节点进行依次对比效率低下，算法复杂度达到O(N^3)，主要原因在于其追求完全比对和最小修改，而React、Vue则是放弃了完全比对及最小修改，才实现从O(N^3) => O(N)**
   优化点有： 分层diff(同层节点中双端比较法)
   当发生以下情况则跳过比对，变为插入或删除操作：

   - **「组件的Type(Tagname)不一致」**，原因是绝大多数情况拥有相同type的两个组件将会生成相似的树形结构，拥有不同type的两个组件将会生成不同的树形结构，所以type不一致可以放弃继续比对。
   - **「列表组件的Key不一致」**，旧树中无新Key或反之。毕竟key是元素的身份id，能直接对应上是否是同一个节点。
   - 对触发了getter/setter 的组件进行diff，精准减少diff范围

   具体实现： https://blog.csdn.net/frontend_frank/article/details/114297890

5. 事件委派的原理
   DOM1/2事件级 => 事件冒泡

6. 前端缓存流程
   浏览器首次加载资源成功时，服务器返回200，此时浏览器不仅将资源下载下来，而且把response的header(里面的date属性非常重要，用来计算第二次相同资源时当前时间和date的时间差)一并缓存;
   下一次加载资源时，首先要经过强缓存的处理，cache-control的优先级最高，比如cache-control：no-cache,就直接进入到协商缓存的步骤了，如果cache-control：max-age=xxx,就会先比较当前时间和上一次返回200时的时间差，如果没有超过max-age，命中强缓存，不发请求直接从本地缓存读取该文件（这里需要注意，如果没有cache-control，会取expires的值，来对比是否过期），过期的话会进入下一个阶段，协商缓存
   协商缓存阶段，则向服务器发送header带有If-None-Match和If-Modified-Since的请求，服务器会比较Etag，如果相同，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200;
   协商缓存第二个重要的字段是，If-Modified-Since，如果客户端发送的If-Modified-Since的值跟服务器端获取的文件最近改动的时间，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200;
   **启发式缓存:**

   如果响应中未显示Expires，Cache-Control：max-age或Cache-Control：s-maxage，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜度寿命。通常会根据响应头中的2个时间字段 Date 减去 Last-Modified 值的 10% 作为缓存时间

7. 协商缓存的具体过程
   发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回304状态码-->客户端用缓存的老资源
   如果资源确实过期了
   发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->过期-->返回200状态码-->客户端如第一次接收该资源一样，记下它的cache-control中的max-age、etag、last-modified等
   如果response header中的etag、last-modified在客户端重新向服务端发起请求时，会在request header中换个key名 eTag=>if-none-matched/last-modified=>if-modified-since

   所以协商缓存步骤总结：

   请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。
   如果资源没更改，返回304，浏览器读取本地缓存。
   如果资源有更改，返回200，返回最新的资源

8. 常见的Http header头部有什么?

   按功能划分：通用首部字段/请求头首部字段/响应头首部字段/实体首部字段
   具体字段 : https://juejin.cn/post/6898501518308818951